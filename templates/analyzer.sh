#!/bin/bash
# Stateful Code Analyzer - Generated Script
# Auto-generated from rules on {{GENERATION_DATE}}
#
# USAGE INSTRUCTIONS:
# 1. Place this script in your PROJECT ROOT directory (same level as .csproj/.sln for .NET or pom.xml/build.gradle for Java)
# 2. Make the script executable: chmod +x analyze.sh
# 3. Run the script: ./analyze.sh
#
# OUTPUT FILE:
# - stateful-analysis.json: Upload this file to the web application for detailed analysis and recommendations
#   (Contains only raw findings - recommendations and actions are generated by the backend)
#
# REQUIREMENTS:
# - jq command-line tool (script will attempt to install if missing)
# - Project must be .NET (*.csproj, *.sln) or Java (pom.xml, build.gradle)

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
OUTPUT_FILE="${SCRIPT_DIR}/stateful-analysis.json"
TEMP_FINDINGS="${SCRIPT_DIR}/.findings_temp.json"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

echo -e "${BLUE}╔═══════════════════════════════════════════════╗${NC}"
echo -e "${BLUE}║   Stateful Code Analyzer v2.0                ║${NC}"
echo -e "${BLUE}║   Generated with {{RULES_COUNT}} rules                     ║${NC}"
echo -e "${BLUE}╚═══════════════════════════════════════════════╝${NC}"
echo ""

# Detect project type
PROJECT_TYPE="unknown"
if [ -f *.csproj ] || [ -f *.sln ] || find . -maxdepth 3 -name "*.csproj" | grep -q .; then
    PROJECT_TYPE="dotnet"
    echo -e "${GREEN}✓ Detected .NET project${NC}"
elif [ -f pom.xml ] || [ -f build.gradle ]; then
    PROJECT_TYPE="java"
    echo -e "${GREEN}✓ Detected Java project${NC}"
else
    echo -e "${RED}✗ Could not detect project type${NC}"
    exit 1
fi

# Initialize findings
echo "[]" > "$TEMP_FINDINGS"

# Function to add finding
add_finding() {
    local file="$1"
    local function="$2" 
    local line_num="$3"
    local code="$4"
    local category="$5"
    local severity="$6"
    local remediation="$7"
    
    code=$(echo "$code" | sed 's/"/\\"/g')
    remediation=$(echo "$remediation" | sed 's/"/\\"/g')
    
    local finding=$(cat <<EOF
{
  "filename": "$file",
  "function": "$function", 
  "lineNum": $line_num,
  "code": "$code",
  "category": "$category",
  "severity": "$severity",
  "remediation": "$remediation"
}
EOF
)
    
    local current=$(cat "$TEMP_FINDINGS")
    if [ "$current" = "[]" ]; then
        echo "[$finding]" > "$TEMP_FINDINGS"
    else
        echo "$current" | jq ". += [$finding]" > "$TEMP_FINDINGS.tmp"
        mv "$TEMP_FINDINGS.tmp" "$TEMP_FINDINGS"
    fi
}

# Extract function name
extract_function_name() {
    local file="$1"
    local line_num="$2"
    local start=$((line_num - 30))
    [ $start -lt 1 ] && start=1
    
    awk -v start="$start" -v end="$line_num" '
        NR >= start && NR <= end {
            if (match($0, /(public|private|protected|internal).*\s+\w+\s*\(/)) {
                if (match($0, /\s+(\w+)\s*\(/, arr)) {
                    print arr[1]
                    exit
                }
            }
        }
        END { if (NR < end) print "Unknown" }
    ' "$file" | tail -1
}

# .NET Analysis
analyze_dotnet() {
    echo -e "${YELLOW}Analyzing .NET code...${NC}"
    local total_files=0
    local issues_found=0
    
    while IFS= read -r -d '' file; do
        ((total_files++))
        relative_file="${file#$SCRIPT_DIR/}"
        
{{DOTNET_PATTERNS}}
        
        echo -ne "\rScanned: $total_files files, Found: $issues_found issues"
    done < <(find . -type f -name "*.cs" ! -path "*/bin/*" ! -path "*/obj/*" -print0)
    
    echo ""
    echo -e "${GREEN}✓ .NET analysis complete${NC}"
}

# Java Analysis  
analyze_java() {
    echo -e "${YELLOW}Analyzing Java code...${NC}"
    local total_files=0
    local issues_found=0
    
    while IFS= read -r -d '' file; do
        ((total_files++))
        relative_file="${file#$SCRIPT_DIR/}"
        
{{JAVA_PATTERNS}}
        
        echo -ne "\rScanned: $total_files files, Found: $issues_found issues"
    done < <(find . -type f -name "*.java" ! -path "*/target/*" ! -path "*/build/*" -print0)
    
    echo ""
    echo -e "${GREEN}✓ Java analysis complete${NC}"
}

# Check for jq
if ! command -v jq &> /dev/null; then
    echo -e "${YELLOW}⚠ Installing jq...${NC}"
    if [[ "$OSTYPE" == "darwin"* ]]; then
        brew install jq
    elif [[ "$OSTYPE" == "linux-gnu"* ]]; then
        sudo apt-get install -y jq || sudo yum install -y jq
    fi
fi

# Run analysis
if [ "$PROJECT_TYPE" = "dotnet" ]; then
    analyze_dotnet
elif [ "$PROJECT_TYPE" = "java" ]; then
    analyze_java
fi

# Create output
cat > "$OUTPUT_FILE" <<EOF
{
  "projectType": "$PROJECT_TYPE",
  "scanDate": "$(date -Iseconds)",
  "rootPath": "$SCRIPT_DIR", 
  "findings": $(cat "$TEMP_FINDINGS")
}
EOF

# Cleanup temporary files
rm -f "$TEMP_FINDINGS" "$TEMP_FINDINGS.tmp"

# Summary
TOTAL_ISSUES=$(jq '.findings | length' "$OUTPUT_FILE")
echo ""
echo -e "${BLUE}╔═══════════════════════════════════════════════╗${NC}"
echo -e "${BLUE}║           Analysis Complete!                  ║${NC}"
echo -e "${BLUE}╚═══════════════════════════════════════════════╝${NC}"
echo -e "${GREEN}✓ Output: $OUTPUT_FILE${NC}"
echo -e "${GREEN}✓ Issues found: $TOTAL_ISSUES${NC}"
echo ""